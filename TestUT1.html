<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evaluación Interactiva - Unidad 1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.3s;
        }
        .fade-enter, .fade-leave-to {
            opacity: 0;
        }
        .option-selected {
            border: 2px solid #3b82f6;
            background-color: #dbeafe;
        }
        .correct-answer {
            border: 2px solid #10b981;
            background-color: #d1fae5;
        }
        .wrong-answer {
            border: 2px solid #ef4444;
            background-color: #fee2e2;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="app" class="flex flex-col lg:flex-row">
        <!-- Sidebar Navigation -->
        <div class="sidebar w-full lg:w-64 text-white p-4 bg-blue-900">
            <div class="flex items-center justify-center lg:justify-start mb-8 pt-2">
                <div class="bg-white p-2 rounded-full">
                    <i class="fas fa-network-wired text-2xl text-blue-900"></i>
                </div>
                <h1 class="text-xl ml-3 font-bold">CC-0601</h1>
            </div>
            
            <nav>
                <div class="mb-4 text-sm text-gray-300 uppercase tracking-wider pl-4">Navegación</div>
                <a href="index.html" class="menu-item flex items-center py-3 px-4 rounded-lg mb-1 bg-blue-700">
                    <i class="fas fa-home mr-3"></i>
                    <span>Volver al Inicio</span>
                </a>
                <a href="UT1.html" class="menu-item flex items-center py-3 px-4 rounded-lg mb-1">
                    <i class="fas fa-arrow-left mr-3"></i>
                    <span>Volver a la Unidad 1</span>
                </a>
                
                <div class="mt-8 pt-4 border-t border-blue-800">
                    <div class="text-sm text-gray-400 mb-2">Otras evaluaciones:</div>
                    <a href="#" class="block py-2 px-4 text-sm text-gray-300 hover:bg-blue-800 rounded-lg mb-1 flex items-center">
                        <i class="fas fa-tasks mr-2 w-4 text-center"></i>
                        Test Unidad 2
                    </a>
                    <a href="#" class="block py-2 px-4 text-sm text-gray-300 hover:bg-blue-800 rounded-lg mb-1 flex items-center">
                        <i class="fas fa-tasks mr-2 w-4 text-center"></i>
                        Test Unidad 3
                    </a>
                    <a href="#" class="block py-2 px-4 text-sm text-gray-300 hover:bg-blue-800 rounded-lg flex items-center">
                        <i class="fas fa-tasks mr-2 w-4 text-center"></i>
                        Test Unidad 4
                    </a>
                </div>
            </nav>
        </div>
        
        <!-- Main Content Area -->
        <div class="flex-1 min-h-screen flex flex-col">
            <!-- Header -->
            <header class="bg-blue-600 text-white shadow-md">
                <div class="container mx-auto px-4 py-6">
                    <h1 class="text-2xl md:text-3xl font-bold">Evaluación Interactiva</h1>
                    <p class="text-blue-100">Unidad 1: Introducción a las Redes de Computadoras</p>
            
                    <!-- Progress Bar -->
                    <div class="w-full bg-gray-200 rounded-full h-2.5 mt-4">
                        <div class="bg-blue-400 h-2.5 rounded-full transition-all duration-300" 
                             :style="{width: ((currentQuestionIndex + 1) / questions.length * 100) + '%'}"></div>
                    </div>
                    <div class="flex justify-between text-sm mt-2">
                        <span>Pregunta {{ currentQuestionIndex + 1 }} de {{ questions.length }}</span>
                        <span>{{ Math.round(((currentQuestionIndex + 1) / questions.length) * 100) }}% Completado</span>
                    </div>
                </div>
            </header>

                <!-- Main Content -->
                <main class="container mx-auto px-4 py-8">
                    <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                        <!-- Question -->
                        <div v-if="!quizCompleted" class="question-container">
                            <h2 class="text-xl font-semibold mb-6">{{ currentQuestion.question }}</h2>
                    
                            <!-- Multiple Choice -->
                            <div v-if="currentQuestion.type === 'choice'" class="space-y-3">
                                <div v-for="(option, index) in currentQuestion.options" :key="index"
                                    class="p-4 border rounded-lg cursor-pointer transition-colors"
                                    :class="getOptionClass(option, index)">
                                    <label class="flex items-center cursor-pointer">
                                        <!-- Checkbox para múltiple selección -->
                                        <div v-if="currentQuestion.multiple" class="flex items-center">
                                            <input type="checkbox" 
                                                :checked="isOptionSelected(option, index)"
                                                @change="toggleOption(option, $event)"
                                                class="h-5 w-5 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                                            <span class="ml-3">{{ option.text }}</span>
                                        </div>
                                        <!-- Radio button para selección única -->
                                        <div v-else class="flex items-center">
                                            <input type="radio" 
                                                :checked="isOptionSelected(option, index)"
                                                @change="selectSingleOption(option, $event)"
                                                :name="'question-' + currentQuestionIndex"
                                                class="h-5 w-5 text-blue-600 border-gray-300 focus:ring-blue-500">
                                            <span class="ml-3">{{ option.text }}</span>
                                        </div>
                                    </label>
                                </div>
                            </div>

                            <!-- True/False -->
                            <div v-else-if="currentQuestion.type === 'truefalse'" class="space-y-3">
                                <div v-for="option in ['Verdadero', 'Falso']" :key="option"
                                    @click="selectSingleOption(option)"
                                    class="p-4 border rounded-lg cursor-pointer transition-colors"
                                    :class="getOptionClass(option)">
                                    <div class="flex items-center">
                                        <div class="w-6 h-6 rounded-full border flex items-center justify-center mr-3 flex-shrink-0"
                                            :class="{
                                                'border-green-500': isOptionSelected(option) && isOptionCorrect(option),
                                                'border-red-500': isOptionSelected(option) && !isOptionCorrect(option),
                                                'border-gray-300': !isOptionSelected(option)
                                            }">
                                            <div v-if="isOptionSelected(option)" 
                                                class="w-3 h-3 rounded-full"
                                                :class="{
                                                    'bg-green-500': isOptionCorrect(option),
                                                    'bg-red-500': !isOptionCorrect(option)
                                                }"></div>
                                        </div>
                                        <span>{{ option }}</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Matching -->
                            <div v-else-if="currentQuestion.type === 'matching'" class="space-y-4">
                                <div v-for="(item, index) in currentQuestion.items" :key="index" class="flex items-center">
                                    <span class="w-1/3 font-medium">{{ item.term }}</span>
                                    <select v-model="userAnswers[currentQuestionIndex][index]" 
                                            class="flex-1 ml-4 p-2 border rounded"
                                            :class="{'bg-green-50 border-green-500': isMatchingCorrect(index)}"
                                            :disabled="quizSubmitted">
                                        <option value="">Selecciona una opción</option>
                                        <option v-for="(option, optIndex) in currentQuestion.options" 
                                                :key="optIndex" 
                                                :value="option"
                                                :disabled="isOptionUsed(option, index)">
                                            {{ option }}
                                        </option>
                                    </select>
                                </div>
                            </div>

                    <!-- Feedback -->
                    <div v-if="showFeedback" class="mt-6 p-4 rounded-lg" 
                         :class="isAnswerCorrect ? 'bg-green-50 text-green-700' : 'bg-red-50 text-red-700'">
                        <p class="font-medium">
                            <i :class="isAnswerCorrect ? 'fas fa-check-circle' : 'fas fa-times-circle'" class="mr-2"></i>
                            {{ isAnswerCorrect ? '¡Correcto!' : 'Incorrecto' }}
                        </p>
                        <p class="mt-2" v-html="currentQuestion.explanation"></p>
                    </div>

                    <!-- Navigation Buttons -->
                    <div class="flex justify-between mt-8">
                        <button @click="previousQuestion" 
                                :disabled="currentQuestionIndex === 0"
                                class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg disabled:opacity-50">
                            <i class="fas fa-arrow-left mr-2"></i>Anterior
                        </button>
                        
                        <button v-if="!isLastQuestion" 
                                @click="nextQuestion" 
                                :disabled="!isAnswerSelected"
                                class="px-6 py-2 bg-blue-600 text-white rounded-lg disabled:opacity-50">
                            Siguiente<i class="fas fa-arrow-right ml-2"></i>
                        </button>

                        <button v-else 
                                @click="submitQuiz" 
                                :disabled="!isAnswerSelected"
                                class="px-6 py-2 bg-green-600 text-white rounded-lg disabled:opacity-50">
                            Finalizar<i class="fas fa-check ml-2"></i>
                        </button>
                    </div>
                        </div>

                        <!-- Results -->
                        <div v-else class="text-center py-8">
                            <div class="w-24 h-24 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-6">
                                <i class="fas fa-trophy text-4xl text-yellow-500"></i>
                            </div>
                            <h2 class="text-2xl font-bold mb-2">¡Evaluación Completada!</h2>
                            <p class="text-gray-600 mb-6">Has completado la evaluación de la Unidad 1</p>
                            
                            <div class="bg-blue-50 p-6 rounded-lg max-w-md mx-auto mb-8">
                                <div class="text-4xl font-bold text-blue-600 mb-2">{{ score }}%</div>
                                <div class="w-full bg-gray-200 rounded-full h-4 mb-2">
                                    <div class="bg-blue-600 h-4 rounded-full" 
                                        :style="{width: score + '%'}"></div>
                                </div>
                                <p class="text-sm text-gray-600">
                                    {{ correctAnswers }} de {{ questions.length }} respuestas correctas
                                </p>
                            </div>

                            <div class="space-y-4 max-w-md mx-auto text-left mb-8">
                                <h3 class="font-semibold text-lg">Resumen de respuestas:</h3>
                                <div v-for="(question, index) in questions" :key="index"
                                    class="p-3 border rounded-lg"
                                    :class="{'bg-green-50 border-green-200': isQuestionCorrect(index), 'bg-red-50 border-red-200': !isQuestionCorrect(index)}">
                                    <p class="font-medium">Pregunta {{ index + 1 }}: {{ isQuestionCorrect(index) ? '✓ Correcta' : '✗ Incorrecta' }}</p>
                                </div>
                            </div>

                            <button @click="resetQuiz" 
                                    class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
                                <i class="fas fa-redo mr-2"></i>Reintentar
                            </button>
                        </div>
                    </div>
                </main>

                <!-- Footer -->
                <footer class="bg-gray-800 text-white py-6">
                    <div class="container mx-auto px-4 text-center">
                        <p>© 2025 Escuela Superior Politécnica Agropecuaria de Manabí Manuel Félix López</p>
                        <p class="text-gray-400 text-sm mt-1">Carrera de Computación - Mgtr. Joffre Moreira Pico</p>
                    </div>
                </footer>
            </div>
    </div>

    <!-- Cargar Vue.js localmente -->
    <script src="https://cdn.jsdelivr.net/npm/vue@3.2.47/dist/vue.global.min.js"></script>
    <script>
        const { createApp, ref, computed, onMounted } = Vue;

        // Crear la aplicación Vue
        const app = createApp({
            setup() {
                // Questions data
                const questions = [
                    {
                        type: 'choice',
                        multiple: false,
                        question: '¿Qué es una red de computadoras?',
                        options: [
                            { text: 'Un software de diseño gráfico', correct: false },
                            { text: 'Una conexión de dispositivos para compartir información y recursos', correct: true },
                            { text: 'Un tipo de archivo multimedia', correct: false },
                            { text: 'Un lenguaje de programación', correct: false }
                        ],
                        explanation: 'Una red conecta dispositivos para permitir la comunicación entre ellos.'
                    },
                    {
                        type: 'truefalse',
                        question: 'Las redes WAN son redes de área pequeña.',
                        correctAnswer: 'Falso',
                        explanation: 'Las WAN (Wide Area Network) abarcan grandes extensiones geográficas.'
                    },
                    {
                        type: 'choice',
                        multiple: true,
                        question: '¿Cuáles de los siguientes elementos son componentes de una red?',
                        options: [
                            { text: 'Computadoras', correct: true },
                            { text: 'Switches', correct: true },
                            { text: 'Lámparas', correct: false },
                            { text: 'Cables Ethernet', correct: true }
                        ],
                        explanation: 'Los dispositivos, medios de transmisión y dispositivos de red conforman una red.'
                    },
                    {
                        type: 'matching',
                        question: 'Relacione cada capa del modelo OSI con su función principal.',
                        items: [
                            { term: 'Física', correct: 'Transmisión de bits' },
                            { term: 'Transporte', correct: 'Entrega fiable de datos' },
                            { term: 'Red', correct: 'Direccionamiento IP' },
                            { term: 'Aplicación', correct: 'Interacción del usuario con la red' }
                        ],
                        options: [
                            'Transmisión de bits',
                            'Entrega fiable de datos',
                            'Direccionamiento IP',
                            'Interacción del usuario con la red'
                        ],
                        explanation: 'Cada capa del modelo OSI cumple una función específica dentro del proceso de comunicación.'
                    },
                    {
                        type: 'truefalse',
                        question: 'La capa de sesión del modelo OSI es la responsable de iniciar y mantener una comunicación.',
                        correctAnswer: 'Verdadero',
                        explanation: 'Esta capa establece y gestiona sesiones entre aplicaciones.'
                    },
                    {
                        type: 'choice',
                        multiple: false,
                        question: '¿Cuál es el protocolo principal de la capa de red del modelo TCP/IP?',
                        options: [
                            { text: 'HTTP', correct: false },
                            { text: 'IP', correct: true },
                            { text: 'FTP', correct: false },
                            { text: 'TCP', correct: false }
                        ],
                        explanation: 'La capa Internet usa el protocolo IP para direccionamiento y enrutamiento.'
                    },
                    {
                        type: 'choice',
                        multiple: true,
                        question: 'Selecciona capas del modelo OSI que no tienen correspondencia directa en TCP/IP.',
                        options: [
                            { text: 'Presentación', correct: true },
                            { text: 'Sesión', correct: true },
                            { text: 'Red', correct: false },
                            { text: 'Aplicación', correct: false }
                        ],
                        explanation: 'Las capas Sesión y Presentación están integradas en la capa de Aplicación del TCP/IP.'
                    },
                    {
                        type: 'choice',
                        multiple: false,
                        question: 'El modelo TCP/IP tiene cuántas capas:',
                        options: [
                            { text: '7', correct: false },
                            { text: '5', correct: false },
                            { text: '4', correct: true },
                            { text: '3', correct: false }
                        ],
                        explanation: 'El modelo TCP/IP posee 4 capas principales: Aplicación, Transporte, Internet y Acceso a la red.'
                    },
                    {
                        type: 'truefalse',
                        question: 'En el encapsulamiento, el tráiler se añade en la capa de red.',
                        correctAnswer: 'Falso',
                        explanation: 'El tráiler se añade en la capa de enlace de datos.'
                    },

                ];

                // State
                const currentQuestionIndex = ref(0);
                const userAnswers = ref(Array(questions.length).fill().map(() => ({})));
                const quizSubmitted = ref(false);
                const quizCompleted = ref(false);
                const showFeedback = ref(false);
                const isAnswerCorrect = ref(false);

                // Computed
                const currentQuestion = computed(() => {
                    // Inicializar respuestas cuando cambia la pregunta
                    setTimeout(() => {
                        initializeUserAnswers();
                    }, 0);
                    return questions[currentQuestionIndex.value];
                });
                
                const isLastQuestion = computed(() => currentQuestionIndex.value === questions.length - 1);
                const isAnswerSelected = computed(() => {
                    if (currentQuestion.value.type === 'matching') {
                        return Object.keys(userAnswers.value[currentQuestionIndex.value] || {}).length > 0;
                    }
                    return userAnswers.value[currentQuestionIndex.value] !== undefined && 
                           userAnswers.value[currentQuestionIndex.value] !== null;
                });

                const correctAnswers = computed(() => {
                    return questions.reduce((count, question, index) => {
                        return count + (isQuestionCorrect(index) ? 1 : 0);
                    }, 0);
                });

                const score = computed(() => {
                    return Math.round((correctAnswers.value / questions.length) * 100);
                });

                // Lifecycle Hooks
                onMounted(() => {
                    initializeUserAnswers();
                });

                // Methods
                function initializeUserAnswers() {
                    if (!userAnswers.value[currentQuestionIndex.value]) {
                        if (currentQuestion.value.type === 'choice' && currentQuestion.value.multiple) {
                            userAnswers.value[currentQuestionIndex.value] = [];
                        } else if (currentQuestion.value.type === 'matching') {
                            userAnswers.value[currentQuestionIndex.value] = {};
                        } else {
                            userAnswers.value[currentQuestionIndex.value] = null;
                        }
                    }
                }
                
                function isMatchingCorrect(index) {
                    if (!quizSubmitted.value) return false;
                    const userAnswer = userAnswers.value[currentQuestionIndex.value]?.[index];
                    if (userAnswer === undefined) return false;
                    return userAnswer === currentQuestion.value.items[index].correct;
                }
                
                function isOptionUsed(option, currentIndex) {
                    if (!quizSubmitted.value) return false;
                    return Object.entries(userAnswers.value[currentQuestionIndex.value] || {})
                        .some(([idx, ans]) => parseInt(idx) !== currentIndex && ans === option);
                }

                function isOptionSelected(option, index) {
                    const currentAnswer = userAnswers.value[currentQuestionIndex.value];
                    if (!currentAnswer) return false;
                    
                    if (currentQuestion.value.type === 'choice') {
                        if (currentQuestion.value.multiple) {
                            return Array.isArray(currentAnswer) && 
                                   currentAnswer.some(ans => ans && ans.text === option.text);
                        } else {
                            return currentAnswer && currentAnswer.text === option.text;
                        }
                    } else if (currentQuestion.value.type === 'truefalse') {
                        return currentAnswer === option;
                    } else if (currentQuestion.value.type === 'matching' && index !== undefined) {
                        return currentAnswer[index] !== undefined;
                    }
                    return false;
                }

                function getOptionClass(option, index) {
                    const isSelected = isOptionSelected(option, index);
                    const question = currentQuestion.value;

                    if (!quizSubmitted.value) {
                        return isSelected 
                            ? 'bg-blue-50 border-blue-300' 
                            : 'hover:bg-gray-50';
                    }

                    // Para preguntas de verdadero/falso
                    if (question.type === 'truefalse') {
                        const isCorrect = isOptionCorrect(option);
                        if (isSelected) {
                            return isCorrect 
                                ? 'bg-green-50 border-green-500' 
                                : 'bg-red-50 border-red-500';
                        }
                        return isCorrect ? 'bg-green-50 border-green-300' : 'bg-gray-50';
                    }

                    // Para preguntas de opción múltiple o única
                    if (question.type === 'choice') {
                        if (isSelected) {
                            return option.correct 
                                ? 'bg-green-50 border-green-500' 
                                : 'bg-red-50 border-red-500';
                        }
                        return option.correct ? 'bg-green-50 border-green-300' : 'bg-gray-50';
                    }

                    return 'bg-gray-50';
                }

                function toggleOption(option, event) {
                    if (quizSubmitted.value) return;
                    
                    const currentAnswer = userAnswers.value[currentQuestionIndex.value] || [];
                    const optionIndex = currentAnswer.findIndex(ans => ans.text === option.text);
                    
                    if (optionIndex === -1) {
                        // Agregar la opción si no está seleccionada
                        userAnswers.value[currentQuestionIndex.value] = [...currentAnswer, option];
                    } else {
                        // Quitar la opción si ya está seleccionada
                        const newAnswers = [...currentAnswer];
                        newAnswers.splice(optionIndex, 1);
                        userAnswers.value[currentQuestionIndex.value] = newAnswers;
                    }
                    
                    checkAnswer();
                }

                function selectSingleOption(option, event) {
                    if (quizSubmitted.value) return;
                    userAnswers.value[currentQuestionIndex.value] = option;
                    checkAnswer();
                }

                function checkAnswer() {
                    if (currentQuestion.value.type === 'choice' && currentQuestion.value.multiple) {
                        const selectedOptions = userAnswers.value[currentQuestionIndex.value] || [];
                        const correctOptions = currentQuestion.value.options.filter(opt => opt.correct);
                        
                        // Verificar que se hayan seleccionado todas las opciones correctas y ninguna incorrecta
                        const allCorrect = correctOptions.every(opt => 
                            selectedOptions.some(sel => sel.text === opt.text)
                        ) && selectedOptions.every(sel => 
                            correctOptions.some(opt => opt.text === sel.text)
                        );
                        
                        isAnswerCorrect.value = allCorrect && selectedOptions.length === correctOptions.length;
                    } else if (currentQuestion.value.type === 'choice' && !currentQuestion.value.multiple) {
                        isAnswerCorrect.value = userAnswers.value[currentQuestionIndex.value]?.correct === true;
                    } else if (currentQuestion.value.type === 'truefalse') {
                        isAnswerCorrect.value = userAnswers.value[currentQuestionIndex.value] === currentQuestion.value.correctAnswer;
                    } else if (currentQuestion.value.type === 'matching') {
                        const currentAnswers = userAnswers.value[currentQuestionIndex.value];
                        isAnswerCorrect.value = Object.entries(currentAnswers || {}).every(([index, answer]) => {
                            return answer === currentQuestion.value.items[index].correct;
                        });
                    }
                    
                    showFeedback.value = true;
                    quizSubmitted.value = true;
                }

                function nextQuestion() {
                    if (currentQuestionIndex.value < questions.length - 1) {
                        currentQuestionIndex.value++;
                        showFeedback.value = false;
                        quizSubmitted.value = false;
                    }
                }

                function previousQuestion() {
                    if (currentQuestionIndex.value > 0) {
                        currentQuestionIndex.value--;
                        showFeedback.value = false;
                        quizSubmitted.value = false;
                    }
                }

                function submitQuiz() {
                    if (!quizSubmitted.value) {
                        checkAnswer();
                    }
                    quizCompleted.value = true;
                }

                function resetQuiz() {
                    currentQuestionIndex.value = 0;
                    userAnswers.value = Array(questions.length).fill().map(() => ({}));
                    quizSubmitted.value = false;
                    quizCompleted.value = false;
                    showFeedback.value = false;
                    // Forzar actualización de la UI
                    currentQuestionIndex.value = 0;
                }



                function isOptionCorrect(option) {
                    if (!quizSubmitted.value) return false;
                    
                    if (currentQuestion.value.type === 'choice') {
                        // Para preguntas de opción múltiple o única
                        return option.correct === true;
                    } else if (currentQuestion.value.type === 'truefalse') {
                        // Para preguntas de verdadero/falso
                        return option === currentQuestion.value.correctAnswer;
                    }
                    return false;
                }

                function getOptionClass(option, index) {
                    const isSelected = isOptionSelected(option, index);
                    const isCorrect = isOptionCorrect(option);
                    
                    if (!quizSubmitted.value) {
                        // Antes de enviar, resaltar la opción seleccionada
                        return isSelected 
                            ? 'bg-blue-50 border-blue-300' 
                            : 'hover:bg-gray-50';
                    }
                    
                    // Después de enviar, mostrar retroalimentación
                    if (isCorrect) {
                        // Opción correcta - siempre en verde
                        if (currentQuestion.value.type === 'truefalse' && isSelected) {
                            return 'bg-green-50 border-green-500';
                        } else if (currentQuestion.value.type === 'choice') {
                            return 'bg-green-50 border-green-500';
                        }
                        return 'bg-green-50 border-green-300';
                    } else if (isSelected) {
                        // Opción seleccionada pero incorrecta - en rojo
                        return 'bg-red-50 border-red-500';
                    }
                    
                    // Opción no seleccionada y no es correcta
                    return 'bg-gray-50';
                }

                function getOptionBulletClass(option, index) {
                    if (!quizSubmitted.value) return 'border-gray-300';
                    
                    const isSelected = isOptionSelected(option, index);
                    
                    if (option.correct) {
                        return isSelected ? 'bg-green-100 border-green-500' : 'bg-green-50 border-green-300';
                    } else if (isSelected && !option.correct) {
                        return 'bg-red-100 border-red-500';
                    }
                    return 'border-gray-300';
                }

                function isMatchingCorrect(index) {
                    if (!quizSubmitted.value) return false;
                    const answer = userAnswers.value[currentQuestionIndex.value][index];
                    return answer === currentQuestion.value.items[index].correct;
                }

                function toggleOption(option, event) {
                    if (quizSubmitted.value) return;
                    
                    const currentAnswer = userAnswers.value[currentQuestionIndex.value] || [];
                    const optionIndex = currentAnswer.findIndex(ans => ans && ans.text === option.text);
                    
                    if (optionIndex === -1) {
                        // Agregar la opción si no está seleccionada
                        userAnswers.value[currentQuestionIndex.value] = [...currentAnswer, option];
                    } else {
                        // Quitar la opción si ya está seleccionada
                        const newAnswers = [...currentAnswer];
                        newAnswers.splice(optionIndex, 1);
                        userAnswers.value[currentQuestionIndex.value] = newAnswers;
                    }
                    
                    checkAnswer();
                }
                
                function isOptionUsed(option, currentIndex) {
                    if (!quizSubmitted.value) {
                        const currentAnswers = Object.values(userAnswers.value[currentQuestionIndex.value] || {});
                        return currentAnswers.includes(option) && userAnswers.value[currentQuestionIndex.value][currentIndex] !== option;
                    }
                    return false;
                }

                function isQuestionCorrect(questionIndex) {
                    const question = questions[questionIndex];
                    
                    if (question.type === 'multiple') {
                        return userAnswers.value[questionIndex]?.correct === true;
                    } else if (question.type === 'truefalse') {
                        return userAnswers.value[questionIndex] === question.correctAnswer;
                    } else if (question.type === 'matching') {
                        const answers = userAnswers.value[questionIndex] || {};
                        return Object.entries(answers).every(([index, answer]) => {
                            return answer === question.items[index].correct;
                        });
                    }
                    return false;
                }

                return {
                    questions,
                    currentQuestionIndex,
                    userAnswers,
                    quizSubmitted,
                    quizCompleted,
                    showFeedback,
                    isAnswerCorrect,
                    currentQuestion,
                    isLastQuestion,
                    isAnswerSelected,
                    correctAnswers,
                    score,
                    toggleOption,
                    selectSingleOption,
                    nextQuestion,
                    previousQuestion,
                    submitQuiz,
                    resetQuiz,
                    isOptionSelected,
                    isOptionCorrect,
                    getOptionClass,
                    getOptionBulletClass,
                    isMatchingCorrect,
                    isOptionUsed,
                    isQuestionCorrect
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
